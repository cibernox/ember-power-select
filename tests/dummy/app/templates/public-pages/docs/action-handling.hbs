<h1 class="doc-page-title">Action handling</h1>

<p>
  Ember power select aims to be maximally flexible and because of that it doesn't try to make strong
  assumptions about how you want to use it. Instead it embraces DDAU <em>(Data Down Actions Up)</em> philosophy
  of Ember 2.0 so data flow always is unidirectional and explicit.
</p>

<p>
  Data changes that occur in the component are not propagated to the outside using two-way bindings,
  but rather they are communicated via actions. The main action you're going to use is the <code>onchange</code>
  action.
</p>

<h3><code>onchange</code> Action</h3>

<p>
  This action will fire whenever an option of the component is selected or unselected.
</p>

<p>
  The most common use case when you want changes inside a component to do something on its context
  is expressed this way:
</p>


{{#code-sample as |component|}}
  <pre class="code-sample-snippet template {{if (eq component.activeTab 'template') 'active'}}">
    \{{#power-select
      selected=destination
      options=cities
      onchange=(action "chooseDestination")
      as |name|
    }}
      \{{name}}
    \{{/power-select}}
  </pre>
  <pre class="code-sample-snippet javascript {{if (eq component.activeTab 'javascript') 'active'}}">
    export default Ember.Controller.extend({
      cities: ['Barcelona', 'London', 'New York', 'Porto'],
      destination: 'London',

      actions: {
        chooseDestination(city) {
          this.set('destination', city);
          // this.calculateRoute();
          // this.updatePrice();
        }
      }
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    {{#power-select
      selected=destination
      options=cities
      onchange=(action "chooseDestination")
      as |name|
    }}
      {{name}}
    {{/power-select}}
  </div>
{{/code-sample}}

<p>
  That gives you the freedom of doing whatever suits your need when the user selects a value. <br>
  If the only thing you want to do is update the value, you can make it more concise by using the
  <code>mut</code> helper.
</p>

{{#code-sample as |component|}}
  <pre class="code-sample-snippet template {{if (eq component.activeTab 'template') 'active'}}">
    \{{#power-select
      selected=destination
      options=cities
      onchange=(action (mut destination))
      as |name|
    }}
      \{{name}}
    \{{/power-select}}
  </pre>
  <pre class="code-sample-snippet javascript {{if (eq component.activeTab 'javascript') 'active'}}">
    export default Ember.Controller.extend({
      cities: ['Barcelona', 'London', 'New York', 'Porto'],
      destination: 'London'
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    {{#power-select
      selected=destination
      options=cities
      onchange=(action (mut destination))
      as |name|
    }}
      {{name}}
    {{/power-select}}
  </div>
{{/code-sample}}

<p>
  It might seem a bit more verbose at first for this, the simplest use case possible, but
  it simplifies a lot the mental model and enables some advanced usages that would otherwise be
  very tricky to implement.
</p>

<h3><code>onkeydown</code> Action</h3>

<p>
  The second option you can provide to the component to customize it's behavior is <code>onkeypress</code>.
  This options will be fired whenever the user presses a key while the component or the search input inside
  have the focus.
</p>

<p>
  This action receives two arguments, <code>dropdown</code> and <code>event</code>. The first one is
  an object that you can use to control the component through it's actions (open, close, toggle...).
  The event is the raw <code>keydown</code> event you can use to decide what to do next.
  If you desire to highjack the browsers' default bahaviour you can call `preventDefault` on that
  event. If you want to avoid the component's default behaviour (p.e. open/close the select or
  navigate through the options using the arrow keys) return false from this action.
</p>

<p>
  One particular common use case for this action is to add new options in multiple selects when the
  user introduced free text.
</p>

{{#code-sample as |component|}}
  <pre class="code-sample-snippet template {{if (eq component.activeTab 'template') 'active'}}">
    \{{#power-select-multiple
      selected=selectedCities
      options=cities
      onchange=(action (mut selectedCities))
      onkeydown=(action "handleKeydown")
      as |name|
    }}
      \{{name}}
    \{{/power-select-multiple}}
  </pre>
  <pre class="code-sample-snippet javascript {{if (eq component.activeTab 'javascript') 'active'}}">
    export default Ember.Controller.extend({
      cities: ['Barcelona', 'London', 'New York', 'Porto'],
      selectedCities: [],
      actions: {
        handleKeydown(dropdown, e) {
          if (e.keyCode !== 13) { return; }
          let text = e.target.value;
          if (text.length > 0 && this.get('cities').indexOf(text) === -1) {
            this.get('selectedCities').pushObject(text);
          }
        }
      }
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    {{#power-select-multiple
      selected=selectedCities
      options=cities
      onchange=(action (mut selectedCities))
      onkeydown=(action "handleKeydown")
      as |name|
    }}
      {{name}}
    {{/power-select-multiple}}
  </div>
{{/code-sample}}


<h3><code>onfocus</code> Action</h3>

<p>
  The third action you can use is <code>onfocus</code>. It does exactly what the names suggests and receives <code>(select, event)</code>
</p>

<p>
  You can use this action for many things (fire a request to prefetch data, show a tooltip, trigger some animation ...) but
  perhaps the most straightforward use case is to automatically open the component on focus.
</p>

{{#code-sample as |component|}}
  <pre class="code-sample-snippet template {{if (eq component.activeTab 'template') 'active'}}">
    &lt;input type="text" placeholder="Focus me and press TAB to focus the select"&gt;
    \{{#power-select
      selected=selected
      options=cities
      onchange=(action (mut selected))
      onfocus=(action "handleFocus")
      as |name|
    }}
      \{{name}}
    \{{/power-select}}
  </pre>
  <pre class="code-sample-snippet javascript {{if (eq component.activeTab 'javascript') 'active'}}">
    export default Ember.Controller.extend({
      cities: ['Barcelona', 'London', 'New York', 'Porto'],
      actions: {
        handleFocus(select, e) {
          select.actions.open();
        }
      }
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    <input type="text" placeholder="Focus me and press TAB to focus the select" style="line-height: 2; width: 100%">
    <br>
    <br>
    {{#power-select
      selected=selected
      options=cities
      onchange=(action (mut selected))
      onfocus=(action "handleFocus")
      as |name|
    }}
      {{name}}
    {{/power-select}}
  </div>
{{/code-sample}}

<h3><code>onopen/onclose</code> Actions</h3>

<p>
  As their names suggest, this actions are fired when the component is about to be opened or closed respectively,
  and they both have the same signature <code>(select, event)</code> (the event will be undefined if
  the component is not opened as result of user interaction).
</p>

<p>
  You can use this action for many useful purposes, but since the troll-force is strong in me, I
  want to show a useless example: The select components for spies!
</p>

{{#code-sample as |component|}}
  <pre class="code-sample-snippet template {{if (eq component.activeTab 'template') 'active'}}">
    \{{#if destroyed}}
      The bomb has exploded! Reload to try again :)
    \{{else}}
      \{{#power-select
        selected=number
        options=numbers
        onchange=(action (mut number))
        onopen=(action "startSelfDestroyCountdown")
        placeholder="Once opened this component will destroy itself in 8 seconds"
        as |number|
      }}
        \{{number}}
      \{{/power-select}}
      \{{#if countdown}}&lt;p&gt;This component will be destroyed in \{{counter}} seconds&lt;/p&gt;\{{/if}}
    \{{/if}}
    &lt;p&gt;Selected number: \{{number}}&lt;/p&gt;
  </pre>
  <pre class="code-sample-snippet javascript {{if (eq component.activeTab 'javascript') 'active'}}">
    const numbers = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];
    export default Ember.Controller.extend({
      numbers,
      counter: 8,
      destroyed: Ember.computed.lte('counter', 0),
      startSelfDestroyCountdown() {
        let tick = () => {
          this.decrementProperty('counter');
          if (!this.get('destroyed')) { Ember.run.later(tick, 1000); }
        };
        this.set('countdown', Ember.run.later(tick, 1000));
      }
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    {{#if destroyed}}
      The bomb has exploded! Reload to try again :)
    {{else}}
      {{#power-select
        selected=number
        options=numbers
        onchange=(action (mut number))
        onopen=(action "startSelfDestroyCountdown")
        placeholder="Once opened this component will destroy itself in 8 seconds"
        as |number|
      }}
        {{number}}
      {{/power-select}}
      {{#if countdown}}<p>This component will be destroyed in {{counter}} seconds</p>{{/if}}
    {{/if}}
    <p>Selected number: {{number}}</p>
  </div>
{{/code-sample}}

<p>
  Another neat trick is that you can prevent the component from open/close if you return <code>false</code>
  from this actions, so you have the last word. This is all that takes to create a mandatory select component
  that once opened it cannot be closed until you select some value, and changes
  the styles of the component.
</p>

{{#code-sample as |component|}}
  <pre class="code-sample-snippet template {{if (eq component.activeTab 'template') 'active'}}">
    \{{#power-select
      selected=mandatoryNumber
      options=numbers
      class=selectClass
      dropdownClass=selectClass
      onchange=(action (mut mandatoryNumber))
      onclose=(action "verifyPresence")
      placeholder="I really NEED this info"
      as |number|}}

      \{{number}}

    \{{/power-select}}
  </pre>
  <pre class="code-sample-snippet javascript {{if (eq component.activeTab 'javascript') 'active'}}">
    const numbers = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];
    export default Ember.Controller.extend({
      actions: {
        verifyPresence(select /*, e */) {
          if (this.get('mandatoryNumber')) {
            this.set('selectClass', null);
          } else {
            this.set('selectClass', 'has-error');
            return false;
          }
        }
      }
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    {{#power-select
      selected=mandatoryNumber
      options=numbers
      class=selectClass
      dropdownClass=selectClass
      onchange=(action (mut mandatoryNumber))
      onclose=(action "verifyPresence")
      placeholder="I really NEED this info"
      as |number|}}
      {{number}}
    {{/power-select}}
  </div>
{{/code-sample}}

<p>
  Have I mentioned that your can also render groups?
</p>

<div class="doc-page-nav">
  {{#link-to 'public-pages.docs.how-to-use-it' class="doc-page-nav-link-prev"}}&lt; How to use it{{/link-to}}
  {{#link-to 'public-pages.docs.groups' class="doc-page-nav-link-next"}}Groups &gt;{{/link-to}}
</div>
