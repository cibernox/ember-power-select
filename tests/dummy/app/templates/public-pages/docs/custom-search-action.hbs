<h1 class="doc-page-title">Custom search action</h1>

<p>
  In {{#link-to 'public-pages.docs.the-search'}}The search{{/link-to}} chapter we saw all the possible ways of
  personalizing the way the component can filter but they all had something in common. You had all the
  options available upon initialization and you were just filtering that collection.
</p>

<p>
  There are occasions when having all the options available upfront on the client side is not
  convenient or is downright impossible.
</p>

<p>
  When that's the case you can provide a <code>search</code> action instead of <code>options</code>
  (it's the only situation where the <code>options</code> are not mandatory) that will be invoked with
  the search term whenever the user types on the search box.
</p>

<p>
  Using that option you have complete freedom about how you search. Synchronous, asynchronous, with
  debouncing, using generators, you name it. It's entirely up you you.
  <br>
  There is only three things to know about this action:
  <ul>
    <li>You should return a collection or a promise that resolves to a collection from this action.</li>
    <li>
      You can provide both <code>options</code> and a <code>search</code> action. Those options will be
      the initial set of options, but as soon as the user performs a search, the results of that search
      will be displayed instead.
    </li>
    <li>
      This action <strong>will not be fired</strong> when the search term is blank. It will display the elements
      inside the <code>options</code> instead.
    </li>
  </ul>
</p>

{{#code-sample as |component|}}
  <pre class="code-sample-snippet {{if (eq component.activeTab 'template') 'active'}}">
    \{{#power-select
      search=(action "searchRepo")
      selected=selected
      onchange=(action (mut selected))
      as |repo|
    }}
      \{{repo.full_name}}
    \{{/power-select}}
  </pre>
  <pre class="code-sample-snippet {{if (eq component.activeTab 'javascript') 'active'}}">
    export default Ember.Controller.extend({
      actions: {
        searchRepo(term) {
          if (Ember.isBlank(term)) { return []; }
          const url = `//api.github.com/search/repositories?q=${term}`;
          return ajax({ url }).then(json => json.items);
        }
      }
    });
  </pre>
  <div class="code-sample-snippet result {{if (eq component.activeTab 'result') 'active'}}">
    {{#power-select
      search=(action "searchRepo")
      selected=selected
      onchange=(action (mut selected))
      as |repo|
    }}
      {{repo.full_name}}
    {{/power-select}}
    (It might fail if the API limit is exceeded)
  </div>
{{/code-sample}}

<p>
  It's also worth mentioning that Ember Power Select is smart enough to always prioritize the last request made,
  so in the best scenario avoids expensive repaintings, and in the worst case (when the second request
  resolves before the first), when the first resolves it doesn't override the most recent request.
</p>

<div class="doc-page-nav">
  {{#link-to 'public-pages.docs.styles' class="doc-page-nav-link-prev"}}&lt; Styles{{/link-to}}
  {{#link-to 'public-pages.docs.test-helpers' class="doc-page-nav-link-next"}}Test helpers &gt;{{/link-to}}
</div>
